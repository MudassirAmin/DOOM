<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM ETERNAL LITE - Web Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        /* HUD ELEMENTS */
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }
        
        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 150px;
            transform: skew(-10deg);
        }

        .hud-value {
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px currentColor;
        }

        .hud-label {
            font-size: 14px;
            color: #aaa;
            letter-spacing: 2px;
        }

        #health-val { color: #00aaff; text-shadow: 0 0 10px #00aaff; }
        #ammo-val { color: #ffaa00; text-shadow: 0 0 10px #ffaa00; }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: #0f0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 5px #0f0;
        }

        #crosshair-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9;
        }

        /* DAMAGE OVERLAY */
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%);
            pointer-events: none;
            z-index: 5;
            transition: background 0.1s;
        }

        /* DASH BAR */
        #dash-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 40px);
            width: 100px;
            height: 6px;
            background: #333;
            border: 1px solid #555;
            z-index: 8;
        }
        #dash-fill {
            width: 100%;
            height: 100%;
            background: #00ffff;
            box-shadow: 0 0 5px #00ffff;
        }

        /* MENUS */
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(10, 0, 0, 0.95);
            padding: 40px;
            border: 2px solid #ff3300;
            z-index: 20;
            min-width: 400px;
            box-shadow: 0 0 20px #ff3300;
        }

        /* MAP SELECTOR MENU */
        #map-selector {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(5, 5, 10, 0.98);
            padding: 30px;
            border: 2px solid #00aaff;
            z-index: 25;
            min-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 20px #00aaff;
        }
        
        h1 { margin: 0 0 10px 0; color: #ff3300; font-size: 3em; text-transform: uppercase; letter-spacing: 5px; }
        .key { color: #00ffff; font-weight: bold; }

        .btn-main {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 15px;
            background: #222;
            color: white;
            border: 1px solid #ff3300;
            cursor: pointer;
            font-family: inherit;
            font-size: 1.2em;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
        }
        .btn-main:hover { background: #ff3300; color: #000; }

        .btn-map {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            background: #111;
            color: #00aaff;
            border: 1px solid #0055aa;
            cursor: pointer;
            font-family: inherit;
            transition: 0.2s;
            text-align: left;
            display: flex;
            justify-content: space-between;
        }
        .btn-map:hover { background: #00aaff; color: #000; }
        
        .status-msg { margin-top:10px; font-size: 0.8em; color: #aaa; }
        .error-msg { color: #ff5555; }
        .success-msg { color: #55ff55; }

        /* DEBUG MENU */
        #debug-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 30;
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
        }
        #debug-panel {
            display: none;
            position: absolute;
            top: 40px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0f0;
            padding: 15px;
            z-index: 30;
            color: white;
            width: 250px;
            max-height: 80vh;
            overflow-y: auto;
            font-size: 12px;
        }
        .debug-row {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .debug-row input[type="number"], .debug-row input[type="range"] {
            width: 80px;
            background: #333;
            color: #0f0;
            border: 1px solid #555;
            padding: 2px;
        }
        h3 { border-bottom: 1px solid #555; padding-bottom: 5px; color: #ffaa00; margin-top: 15px; }

        /* NOTIFICATIONS */
        #pickup-msg {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 5px orange;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 15;
        }

    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="crosshair"></div>
    <div id="crosshair-ring"></div>
    
    <!-- DASH INDICATOR (Near Crosshair) -->
    <div id="dash-container"><div id="dash-fill"></div></div>

    <!-- PICKUP TEXT -->
    <div id="pickup-msg">+ 20 SHELLS</div>

    <!-- MAIN HUD -->
    <div id="hud">
        <div class="hud-panel" style="border-color: #00aaff;">
            <div id="health-val" class="hud-value">100</div>
            <div class="hud-label">HEALTH</div>
        </div>
        <div class="hud-panel" style="border-color: #ffaa00;">
            <div id="ammo-val" class="hud-value">20</div>
            <div class="hud-label">SHELLS</div>
        </div>
    </div>

    <!-- DEBUG MENU -->
    <button id="debug-btn">DEV SETTINGS</button>
    <div id="debug-panel">
        <h3>PLAYER</h3>
        <div class="debug-row">
            <span>Max Health</span>
            <input type="number" id="inp-p-maxhp" onchange="updateConfig()">
        </div>
        <div class="debug-row">
            <span>Move Speed</span>
            <input type="number" id="inp-p-speed" onchange="updateConfig()">
        </div>
        <div class="debug-row">
            <span>Dash Speed</span>
            <input type="number" id="inp-p-dash" onchange="updateConfig()">
        </div>

        <h3>COMBAT</h3>
        <div class="debug-row">
            <span>Shotgun Dmg</span>
            <input type="number" id="inp-w-dmg" onchange="updateConfig()">
        </div>
        <div class="debug-row">
            <span>Pellet Count</span>
            <input type="number" id="inp-w-pellets" onchange="updateConfig()">
        </div>
        <div class="debug-row">
            <span>Spread</span>
            <input type="number" id="inp-w-spread" step="0.01" onchange="updateConfig()">
        </div>

        <h3>ENEMIES (New Spawns)</h3>
        <div class="debug-row">
            <span>Imp HP</span>
            <input type="number" id="inp-e-imphp" onchange="updateConfig()">
        </div>
        <div class="debug-row">
            <span>Soldier HP</span>
            <input type="number" id="inp-e-soldierhp" onchange="updateConfig()">
        </div>
        <div class="debug-row">
            <span>Aggro Range</span>
            <input type="number" id="inp-e-aggro" onchange="updateConfig()">
        </div>
        
        <div class="debug-row" style="margin-top:15px;">
            <button onclick="spawnWave()" style="width:100%; padding: 5px; background: #500; color:white; border:1px solid red; cursor:pointer;">SPAWN WAVE</button>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="instructions">
        <h1>SLAYER MODE</h1>
        <p><span class="key">WASD</span> Move | <span class="key">SPACE</span> Jump (x2)</p>
        <p><span class="key">SHIFT</span> Dash | <span class="key">L-CLICK</span> Super Shotgun</p>
        <br>
        <button id="btn-start" class="btn-main">PLAY DEFAULT CITY</button>
        <button id="btn-maps" class="btn-main" style="border-color: #00aaff; color: #00aaff;">CUSTOM MAPS</button>
        
        <!-- Weapon Status -->
        <div id="weapon-status" class="status-msg">Weapons: Default</div>
    </div>

    <!-- MAP SELECTOR -->
    <div id="map-selector">
        <h2 style="color: #00aaff; border-bottom: 1px solid #333; padding-bottom:10px;">ONLINE MAPS</h2>
        
        <div id="map-list-container" style="margin-bottom: 20px; text-align: left; max-height: 300px; overflow-y: auto;">
            <div id="map-loading-msg" style="color: #aaa; text-align: center; padding: 20px;">
                Connecting to /maps/map_list.json...
            </div>
        </div>

        <button id="btn-cancel-map" class="btn-main" style="border-color: #555; color: #aaa; padding: 10px;">CANCEL</button>
    </div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration & State ---
        window.CONFIG = {
            moveSpeed: 30, jumpForce: 30, gravity: 70, friction: 8, 
            dashSpeed: 90, dashCooldown: 1.2,
            playerMaxHealth: 100, playerStartAmmo: 20,
            shotgunDamage: 15, shotgunPellets: 8, shotgunSpread: 0.1, shotgunCooldown: 1.0,
            impHp: 40, impSpeed: 10, soldierHp: 80, soldierSpeed: 8, aggroRange: 80, enemyFireRate: 2.0,
            lavaHeight: 2
        };

        const STATE = {
            health: CONFIG.playerMaxHealth,
            ammo: CONFIG.playerStartAmmo,
            lastShotTime: 0,
            isDead: false,
            currentMap: 'default'
        };

        // --- Globals ---
        let camera, scene, renderer, controls;
        let weaponGroup;
        
        // Physics
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const playerCollider = new THREE.Box3();
        let isGrounded = false;
        let jumpCount = 0;
        let lastTime = performance.now();
        
        // Game State
        let canDash = true;
        let dashTimer = 0;
        let lavaMesh;
        
        const moveState = { forward: false, backward: false, left: false, right: false };
        let buildings = []; // Physics boxes (AABB)
        let buildingMeshes = []; // Visuals
        let scriptedObjects = []; // Objects with scripts (patrol/rotate)
        
        // Entities
        let enemies = [];
        let projectiles = [];
        let drops = [];
        let particles = [];

        // Assets
        let windowTexture, plainTexture;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        init();
        initDebug();
        // Automatically check for custom content on load
        fetchWeaponConfigs();
        
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0505); 
            scene.fog = new THREE.FogExp2(0x1a0505, 0.015);

            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 50; 

            // Lights
            const ambientLight = new THREE.AmbientLight(0xff8888, 0.4); 
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(100, 100, 50);
            scene.add(dirLight);

            // Textures
            createProceduralTextures();

            // Default World (Will be generated on start click)
            createLava();

            // Player Weapon
            createShotgun();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            
            // Event Listeners for Menus
            document.getElementById('btn-start').addEventListener('click', () => {
                startGame('default');
            });
            document.getElementById('btn-maps').addEventListener('click', () => {
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('map-selector').style.display = 'block';
                fetchMapList(); // Fetch when menu opens
            });
            document.getElementById('btn-cancel-map').addEventListener('click', () => {
                document.getElementById('map-selector').style.display = 'none';
                document.getElementById('instructions').style.display = 'block';
            });

            controls.addEventListener('lock', () => {
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('map-selector').style.display = 'none';
                document.getElementById('debug-panel').style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                if(!STATE.isDead) document.getElementById('instructions').style.display = 'block';
            });

            // Input
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);
        }

        // ==========================================
        //        ASSET LOADING SYSTEM
        // ==========================================

        function fetchMapList() {
            const listContainer = document.getElementById('map-list-container');
            const msg = document.getElementById('map-loading-msg');
            msg.style.display = 'block';
            msg.innerText = 'Connecting to maps/map_list.json...';
            msg.className = '';

            // 1. Look for the manifest file
            fetch('maps/map_list.json')
                .then(response => {
                    if (!response.ok) throw new Error("Manifest not found");
                    return response.json();
                })
                .then(fileList => {
                    // Success!
                    msg.style.display = 'none';
                    // Clear old buttons (except msg)
                    Array.from(listContainer.getElementsByTagName('button')).forEach(b => b.remove());

                    if (!Array.isArray(fileList) || fileList.length === 0) {
                        msg.innerText = "Map list is empty.";
                        msg.style.display = 'block';
                        return;
                    }

                    fileList.forEach(filename => {
                        const btn = document.createElement('button');
                        btn.className = 'btn-map';
                        btn.innerHTML = `<span>${filename}</span> <span class="success-msg">ONLINE</span>`;
                        btn.onclick = () => loadMapFromServer(filename);
                        listContainer.appendChild(btn);
                    });
                })
                .catch(err => {
                    console.warn("Map Loader:", err);
                    msg.className = 'error-msg';
                    msg.innerHTML = `
                        <strong>ERROR:</strong> Could not find <code>maps/map_list.json</code>.<br><br>
                        Since this is a website, you must create a file named 
                        <strong>map_list.json</strong> in your maps folder 
                        that lists your map filenames.<br>
                        <em>Example: ["level1.json", "arena.json"]</em>
                    `;
                });
        }

        function loadMapFromServer(filename) {
            fetch(`maps/${filename}`)
                .then(res => {
                    if(!res.ok) throw new Error("File not found");
                    return res.json();
                })
                .then(mapData => {
                    startGame('custom', mapData);
                })
                .catch(err => {
                    alert("Failed to load map file: " + filename);
                    console.error(err);
                });
        }

        function fetchWeaponConfigs() {
            const statusDiv = document.getElementById('weapon-status');
            
            // Look for weapons/weapon_list.json
            fetch('weapons/weapon_list.json')
                .then(res => {
                    if(!res.ok) return null;
                    return res.json();
                })
                .then(weaponFiles => {
                    if(!weaponFiles) return; // No weapons found, stay default

                    // For now, in this Lite engine, we assume the weapon files 
                    // are JSON configs that override game constants
                    // e.g. "super_shotgun.json" -> { "shotgunDamage": 50, "shotgunPellets": 20 }
                    
                    let loadedCount = 0;
                    weaponFiles.forEach(wFile => {
                        fetch(`weapons/${wFile}`)
                            .then(r => r.json())
                            .then(wData => {
                                // Apply Overrides
                                if(wData.shotgunDamage) CONFIG.shotgunDamage = wData.shotgunDamage;
                                if(wData.shotgunPellets) CONFIG.shotgunPellets = wData.shotgunPellets;
                                if(wData.shotgunSpread) CONFIG.shotgunSpread = wData.shotgunSpread;
                                if(wData.shotgunCooldown) CONFIG.shotgunCooldown = wData.shotgunCooldown;
                                
                                loadedCount++;
                                statusDiv.innerText = `Weapons: Loaded custom config from ${wFile}`;
                                statusDiv.className = 'status-msg success-msg';
                            });
                    });
                })
                .catch(err => {
                    // Silent fail for weapons is fine, just means using defaults
                    console.log("No custom weapons found or invalid manifest.");
                });
        }

        function startGame(mode, mapData) {
            STATE.currentMap = mode;
            
            // Clear current level
            clearLevel();
            
            if (mode === 'default') {
                generateCity();
                finishStart();
            } else if (mode === 'custom' && mapData) {
                buildLevelFromJSON(mapData);
                finishStart();
            }
        }

        function finishStart() {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('map-selector').style.display = 'none';
            resetPlayerState();
            spawnWave(); // Spawn enemies
            controls.lock();
        }

        function clearLevel() {
            // Remove old buildings/geometry
            buildingMeshes.forEach(m => scene.remove(m));
            buildingMeshes = [];
            buildings = [];
            scriptedObjects = [];
            
            // Remove enemies
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            
            // Remove drops
            drops.forEach(d => scene.remove(d.mesh));
            drops = [];
            
            // Remove projectiles
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles = [];
        }

        function buildLevelFromJSON(objects) {
            if (!Array.isArray(objects)) {
                alert("Invalid Map Format: Root must be an array of objects.");
                return;
            }

            console.log("Building level with " + objects.length + " objects.");
            
            const geometries = {
                box: new THREE.BoxGeometry(1, 1, 1),
                sphere: new THREE.SphereGeometry(1, 16, 16), // Base size 1 for scaling
                cylinder: new THREE.CylinderGeometry(0.5, 0.5, 1, 16)
            };

            objects.forEach(obj => {
                if (obj.operation === 'subtract') return; // Not supporting boolean ops in Lite version yet

                const geo = geometries[obj.type] || geometries.box;
                const mat = new THREE.MeshStandardMaterial({ color: obj.color, roughness: 0.5, metalness: 0.2 });
                const mesh = new THREE.Mesh(geo, mat);

                mesh.position.set(obj.pos.x, obj.pos.y, obj.pos.z);
                mesh.rotation.set(obj.rot.x, obj.rot.y, obj.rot.z);
                mesh.scale.set(obj.scl.x, obj.scl.y, obj.scl.z);

                scene.add(mesh);
                buildingMeshes.push(mesh);

                // Create Physics Box (AABB)
                // Note: Complex rotations might not have perfect collision in this Lite engine
                const box = new THREE.Box3();
                box.setFromObject(mesh);
                buildings.push(box);

                // Handle Scripts
                if (obj.script && obj.script.type !== 'static') {
                    scriptedObjects.push({
                        mesh: mesh,
                        box: box, // Reference to update physics
                        data: obj.script,
                        startPos: mesh.position.clone(),
                        currentWpIndex: 0,
                        waitTimer: 0
                    });
                }
            });
        }

        function createProceduralTextures() {
            // Building Window Texture
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#222'; ctx.fillRect(0,0,64,64);
            for(let y=4; y<64; y+=12) {
                for(let x=4; x<64; x+=12) {
                    ctx.fillStyle = Math.random() > 0.6 ? (Math.random()>0.9?'#ffaa00':'#00aaff') : '#111';
                    ctx.fillRect(x, y, 6, 8);
                }
            }
            windowTexture = new THREE.CanvasTexture(canvas);
            windowTexture.magFilter = THREE.NearestFilter;
            windowTexture.wrapS = THREE.RepeatWrapping;
            windowTexture.wrapT = THREE.RepeatWrapping;

            plainTexture = new THREE.MeshPhongMaterial({ color: 0x333333 });
        }

        function createShotgun() {
            weaponGroup = new THREE.Group();
            
            // Barrels
            const barrelGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
            barrelGeo.rotateX(Math.PI / 2);
            const barrelMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
            
            const leftBarrel = new THREE.Mesh(barrelGeo, barrelMat);
            leftBarrel.position.set(-0.12, -0.2, -0.5);
            
            const rightBarrel = new THREE.Mesh(barrelGeo, barrelMat);
            rightBarrel.position.set(0.12, -0.2, -0.5);
            
            // Stock/Body
            const stockGeo = new THREE.BoxGeometry(0.5, 0.3, 1.0);
            const stockMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 }); // Brown wood
            const stock = new THREE.Mesh(stockGeo, stockMat);
            stock.position.set(0, -0.3, 0.2);

            weaponGroup.add(leftBarrel, rightBarrel, stock);
            
            // Attach to camera
            camera.add(weaponGroup);
            
            // Position gun in view
            weaponGroup.position.set(0.5, -0.5, -0.5);
            scene.add(camera); // Camera needs to be in scene for children to render if not already
        }

        function spawnWave() {
            // Remove old dead enemies if any
            enemies = enemies.filter(e => e.hp > 0);
            if(enemies.length > 20) return; // Cap

            for(let i=0; i<5; i++) {
                // Random position above buildings or zero if no buildings
                let spawnPos = new THREE.Vector3((Math.random()-0.5)*100, 5, (Math.random()-0.5)*100);
                
                // Try to spawn on a building if they exist
                if (buildings.length > 0) {
                    const rIdx = Math.floor(Math.random() * buildings.length);
                    const center = new THREE.Vector3();
                    buildings[rIdx].getCenter(center);
                    spawnPos.set(center.x, center.y + 5, center.z);
                }
                
                const type = Math.random() > 0.6 ? 'soldier' : 'imp';
                spawnEnemy(spawnPos.x, spawnPos.y, spawnPos.z, type);
            }
        }

        function spawnEnemy(x, y, z, type) {
            const isImp = type === 'imp';
            const color = isImp ? 0xff3300 : 0x44aa44; // Red or Green
            const scale = isImp ? 1.5 : 2.0;
            const hp = isImp ? CONFIG.impHp : CONFIG.soldierHp;
            const speed = isImp ? CONFIG.impSpeed : CONFIG.soldierSpeed;

            // Simple geometry for enemies
            const geo = isImp ? new THREE.DodecahedronGeometry(0.8) : new THREE.BoxGeometry(1.2, 2, 1.2);
            const mat = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            
            // Add eyes
            const eyeGeo = new THREE.BoxGeometry(0.2, 0.1, 0.1);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const eye = new THREE.Mesh(eyeGeo, eyeMat);
            eye.position.set(0, 0.3, 0.5);
            if(!isImp) eye.position.y = 0.5;
            mesh.add(eye);

            scene.add(mesh);

            enemies.push({
                mesh: mesh,
                type: type,
                hp: hp,
                maxHp: hp,
                speed: speed,
                state: 'chase', // chase, attack, pain
                lastAttack: 0,
                velocity: new THREE.Vector3()
            });
        }

        // --- Game Logic ---

        function onMouseDown(e) {
            if (controls.isLocked && e.button === 0) {
                shootWeapon();
            }
        }

        function shootWeapon() {
            const now = performance.now() / 1000;
            if (now - STATE.lastShotTime < CONFIG.shotgunCooldown) return;
            if (STATE.ammo <= 0) {
                // Empty click sound
                playSound(400, 'square', 0.1, 0.1);
                return;
            }

            STATE.ammo -= 2; // Super shotgun uses 2
            if(STATE.ammo < 0) STATE.ammo = 0;
            updateHud();
            STATE.lastShotTime = now;

            // Recoil Animation
            const originalPos = weaponGroup.position.clone();
            const recoilPos = originalPos.clone().add(new THREE.Vector3(0, 0.2, 0.5));
            
            // Simple tween-like effect manually or simple logic
            // We'll just jerk it back and let update loop restore it
            weaponGroup.position.z += 0.4; 
            weaponGroup.rotation.x += 0.2;

            // Muzzle Flash
            createMuzzleFlash();

            // Sound
            playSound(100, 'sawtooth', 0.2, 0.5);

            // Raycast / Logic
            // Shotgun spread
            for(let i=0; i<CONFIG.shotgunPellets; i++) {
                // Calculate spread direction
                const spreadX = (Math.random() - 0.5) * CONFIG.shotgunSpread;
                const spreadY = (Math.random() - 0.5) * CONFIG.shotgunSpread;
                
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(camera.quaternion);
                
                // Add spread
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
                const up = new THREE.Vector3(0,1,0).applyQuaternion(camera.quaternion);
                dir.addScaledVector(right, spreadX);
                dir.addScaledVector(up, spreadY);
                dir.normalize();

                const raycaster = new THREE.Raycaster(camera.position, dir);
                
                // Check enemy hits
                const enemyMeshes = enemies.map(e => e.mesh);
                const intersects = raycaster.intersectObjects(enemyMeshes);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    if (hit.distance < 100) {
                        // Find enemy data
                        const enemy = enemies.find(e => e.mesh === hit.object || e.mesh === hit.object.parent);
                        if (enemy) damageEnemy(enemy, CONFIG.shotgunDamage, hit.point);
                        createImpact(hit.point, 0xffff00);
                    }
                } else {
                    // Check building hits for visuals
                    const intersectsBuild = raycaster.intersectObjects(buildingMeshes);
                    if(intersectsBuild.length > 0 && intersectsBuild[0].distance < 100) {
                        createImpact(intersectsBuild[0].point, 0x555555);
                    }
                }
            }
        }

        function damageEnemy(enemy, amount, point) {
            enemy.hp -= amount;
            
            // Hitmarker Effect (Knockback visual)
            enemy.mesh.position.addScaledVector(camera.getWorldDirection(new THREE.Vector3()), 0.5);
            enemy.mesh.material.emissive.setHex(0xffffff);
            setTimeout(() => {
                if(enemies.includes(enemy)) {
                     const color = enemy.type === 'imp' ? 0xff3300 : 0x44aa44;
                     enemy.mesh.material.emissive.setHex(color);
                }
            }, 100);

            if (enemy.hp <= 0) {
                killEnemy(enemy);
            }
        }

        function killEnemy(enemy) {
            // Remove mesh
            scene.remove(enemy.mesh);
            
            // Spawn Particles
            for(let i=0; i<8; i++) {
                createParticle(enemy.mesh.position, 0xff0000, 2);
            }

            // Drop Items
            spawnDrop(enemy.mesh.position);

            // Remove from array
            const index = enemies.indexOf(enemy);
            if (index > -1) enemies.splice(index, 1);
        }

        function spawnDrop(pos) {
            const type = Math.random() > 0.5 ? 'health' : 'ammo';
            const color = type === 'health' ? 0x0000ff : 0xffaa00;
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            
            // Light
            const light = new THREE.PointLight(color, 1, 10);
            mesh.add(light);
            
            scene.add(mesh);
            drops.push({ mesh, type, age: 0 });
        }

        function createMuzzleFlash() {
            const flash = new THREE.PointLight(0xffaa00, 5, 10);
            flash.position.set(0.5, -0.5, -2);
            flash.position.applyMatrix4(camera.matrixWorld);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
        }

        function createImpact(pos, color) {
            const geo = new THREE.SphereGeometry(0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            setTimeout(() => scene.remove(mesh), 500);
        }

        function createParticle(pos, color, speed) {
            const p = {
                mesh: new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color:color})),
                vel: new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar(Math.random()*speed),
                life: 1.0
            };
            p.mesh.position.copy(pos);
            scene.add(p.mesh);
            particles.push(p);
        }

        // --- Logic Updates ---

        function updateEnemies(delta, time) {
            const playerPos = camera.position;

            enemies.forEach(e => {
                const dist = e.mesh.position.distanceTo(playerPos);
                
                // Look at player
                e.mesh.lookAt(playerPos);

                // AI Logic (Simple Chaser/Hover)
                if (dist < CONFIG.aggroRange) {
                    const dirToPlayer = new THREE.Vector3().subVectors(playerPos, e.mesh.position).normalize();
                    
                    // Move towards player
                    const moveSpeed = e.speed * delta;
                    e.mesh.position.addScaledVector(dirToPlayer, moveSpeed);

                    // Attack
                    if (time - e.lastAttack > CONFIG.enemyFireRate && dist < 40) {
                        enemyShoot(e);
                        e.lastAttack = time;
                    }
                }

                // Bobbing effect
                e.mesh.position.y += Math.sin(time * 3) * 0.02;
            });
        }

        function enemyShoot(enemy) {
            const projGeo = new THREE.SphereGeometry(0.3);
            const color = enemy.type === 'imp' ? 0xff4400 : 0x00ff00;
            const projMat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(projGeo, projMat);
            
            mesh.position.copy(enemy.mesh.position);
            
            // Aim at player (with slight prediction or error could go here)
            const dir = new THREE.Vector3().subVectors(camera.position, enemy.mesh.position).normalize();
            
            scene.add(mesh);
            projectiles.push({
                mesh: mesh,
                velocity: dir.multiplyScalar(30), // Speed
                life: 3.0,
                damage: enemy.type === 'imp' ? 10 : 5
            });
        }

        function updateProjectiles(delta) {
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.life -= delta;
                p.mesh.position.addScaledVector(p.velocity, delta);

                // Player Hit Check
                if (p.mesh.position.distanceTo(camera.position) < 1.5) {
                    takeDamage(p.damage);
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Building Hit check (Simple floor/dist check for perf)
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }

        function takeDamage(amount) {
            if (STATE.isDead) return;
            STATE.health -= amount;
            
            // Red Flash
            const overlay = document.getElementById('damage-overlay');
            overlay.style.background = `radial-gradient(circle, transparent 20%, rgba(255,0,0,0.6) 100%)`;
            setTimeout(() => {
                overlay.style.background = `radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%)`;
            }, 300);

            if (STATE.health <= 0) {
                STATE.health = 0;
                die();
            }
            updateHud();
        }

        function die() {
            STATE.isDead = true;
            controls.unlock();
            const inst = document.getElementById('instructions');
            inst.innerHTML = `
                <h1 style="color:red">YOU DIED</h1>
                <p>RIP AND TEAR... UNTIL IT IS DONE.</p>
                <br>
                <button onclick="location.reload()" class="btn-main">RESTART GAME</button>
            `;
            inst.style.display = 'block';
        }

        function resetPlayerState() {
            STATE.health = CONFIG.playerMaxHealth;
            STATE.ammo = CONFIG.playerStartAmmo;
            STATE.isDead = false;
            
            // Respawn player
            camera.position.set(0, 50, 0);
            velocity.set(0,0,0);
            updateHud();
        }

        function updateDrops(delta, time) {
            const playerPos = camera.position;
            
            for(let i=drops.length-1; i>=0; i--) {
                const d = drops[i];
                d.mesh.rotation.y += delta * 2;
                d.mesh.position.y += Math.sin(time * 5) * 0.01;

                // Collect
                if (d.mesh.position.distanceTo(playerPos) < 3) {
                    if (d.type === 'health') {
                        STATE.health = Math.min(STATE.health + 25, CONFIG.playerMaxHealth);
                        showPickup('+ 25 HEALTH', '#00aaff');
                    } else {
                        STATE.ammo = Math.min(STATE.ammo + 10, 100);
                        showPickup('+ 10 SHELLS', '#ffaa00');
                    }
                    updateHud();
                    scene.remove(d.mesh);
                    drops.splice(i, 1);
                    playSound(600, 'sine', 0.1, 0.1);
                }
            }
        }

        function showPickup(text, color) {
            const el = document.getElementById('pickup-msg');
            el.innerText = text;
            el.style.color = color;
            el.style.textShadow = `0 0 5px ${color}`;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 1500);
        }

        function updateHud() {
            document.getElementById('health-val').innerText = Math.floor(STATE.health);
            document.getElementById('ammo-val').innerText = Math.floor(STATE.ammo);
        }

        function playSound(freq, type, dur, vol) {
             // Simple synth for sound effects
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const osc = audioCtx.createOscillator();
             const gain = audioCtx.createGain();
             osc.type = type;
             osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
             osc.frequency.exponentialRampToValueAtTime(freq/4, audioCtx.currentTime + dur);
             gain.gain.setValueAtTime(vol, audioCtx.currentTime);
             gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
             osc.connect(gain);
             gain.connect(audioCtx.destination);
             osc.start();
             osc.stop(audioCtx.currentTime + dur);
        }

        // --- Core Loop ---
        function updateScriptedObjects(delta) {
            scriptedObjects.forEach(obj => {
                const script = obj.data;
                const mesh = obj.mesh;
                
                if (script.type === 'rotate') {
                    const axis = script.axis || 'y';
                    mesh.rotation[axis] += (script.speed || 1) * delta;
                    obj.box.setFromObject(mesh); // Update collision box
                } 
                else if (script.type === 'patrol' && script.waypoints.length > 0) {
                    const target = script.waypoints[obj.currentWpIndex];
                    const targetVec = new THREE.Vector3(target.x, target.y, target.z);
                    const dist = mesh.position.distanceTo(targetVec);

                    if (dist < 0.5) {
                        // Reached waypoint
                        obj.waitTimer += delta;
                        if (obj.waitTimer >= (target.waitTime || 0)) {
                            obj.currentWpIndex = (obj.currentWpIndex + 1) % script.waypoints.length;
                            obj.waitTimer = 0;
                        }
                    } else {
                        // Move
                        const dir = new THREE.Vector3().subVectors(targetVec, mesh.position).normalize();
                        mesh.position.addScaledVector(dir, (script.speed || 5) * delta);
                        obj.box.setFromObject(mesh); // Update collision box
                        
                        // Move entities standing on this platform? (Simple version: no friction)
                        // If we wanted platforms we'd need to move player if intersects
                    }
                }
            });
        }

        function updatePhysics(delta) {
            if (!controls.isLocked || STATE.isDead) return;

            velocity.x -= velocity.x * CONFIG.friction * delta;
            velocity.z -= velocity.z * CONFIG.friction * delta;
            velocity.y -= CONFIG.gravity * delta;

            direction.z = Number(moveState.forward) - Number(moveState.backward);
            direction.x = Number(moveState.right) - Number(moveState.left);
            direction.normalize();

            if (moveState.forward || moveState.backward || moveState.left || moveState.right) {
                const camForward = new THREE.Vector3();
                const camRight = new THREE.Vector3();
                camera.getWorldDirection(camForward);
                camForward.y = 0; camForward.normalize();
                camRight.crossVectors(camForward, camera.up).normalize();

                const moveVector = new THREE.Vector3();
                moveVector.addScaledVector(camForward, direction.z);
                moveVector.addScaledVector(camRight, direction.x);
                
                velocity.x += moveVector.x * CONFIG.moveSpeed * delta * 5; 
                velocity.z += moveVector.z * CONFIG.moveSpeed * delta * 5;
            }

            controls.getObject().position.x += velocity.x * delta;
            updatePlayerCollider();
            if (checkCollisions()) {
                controls.getObject().position.x -= velocity.x * delta;
                velocity.x = 0;
            }

            controls.getObject().position.z += velocity.z * delta;
            updatePlayerCollider();
            if (checkCollisions()) {
                controls.getObject().position.z -= velocity.z * delta;
                velocity.z = 0;
            }

            controls.getObject().position.y += velocity.y * delta;
            updatePlayerCollider();
            isGrounded = false;
            if (checkCollisions()) {
                const movingUp = velocity.y > 0;
                controls.getObject().position.y -= velocity.y * delta;
                velocity.y = 0;
                if (!movingUp) {
                    isGrounded = true;
                    jumpCount = 0;
                }
            }

            if (controls.getObject().position.y < CONFIG.lavaHeight + 1) {
                takeDamage(100);
            }
        }

        function updateWeapon(delta) {
            // Return weapon to idle position
            weaponGroup.position.lerp(new THREE.Vector3(0.5, -0.5, -0.5), delta * 5);
            weaponGroup.rotation.x = THREE.MathUtils.lerp(weaponGroup.rotation.x, 0, delta * 5);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() / 1000;
            const delta = Math.min((performance.now() - lastTime * 1000) / 1000, 0.1); // Safe delta
            
            updatePhysics(0.016); // Fixed step for consistency
            
            if(!STATE.isDead && controls.isLocked) {
                updateEnemies(0.016, time);
                updateProjectiles(0.016);
                updateDrops(0.016, time);
                updateWeapon(0.016);
                updateScriptedObjects(0.016);
            }

            // Lava pulse
            if (lavaMesh) {
                const pulse = (Math.sin(time * 2) + 1) * 0.2 + 0.5;
                lavaMesh.material.color.setHSL(0.05, 1, 0.5 * pulse);
            }
            
            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.life -= 0.016;
                p.mesh.position.addScaledVector(p.vel, 0.016);
                p.mesh.rotation.x += 0.1;
                if(p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i,1);
                }
            }

            // Dash Cooldown UI
            if (!canDash) {
                dashTimer -= 0.016;
                const pct = 100 - (dashTimer / CONFIG.dashCooldown * 100);
                document.getElementById('dash-fill').style.width = `${Math.min(pct, 100)}%`;
                if (dashTimer <= 0) {
                    canDash = true;
                    document.getElementById('dash-fill').style.width = '100%';
                }
            }
            
            lastTime = time;
            renderer.render(scene, camera);
        }

        // --- Inputs & Config ---

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = true; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = true; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = true; break;
                case 'ArrowRight': case 'KeyD': moveState.right = true; break;
                case 'Space':
                    if (controls.isLocked) {
                        if (isGrounded) {
                            velocity.y = CONFIG.jumpForce;
                            isGrounded = false;
                            jumpCount = 1;
                        } else if (jumpCount < 2) {
                            velocity.y = CONFIG.jumpForce;
                            jumpCount++;
                        }
                    }
                    break;
                case 'ShiftLeft': case 'ShiftRight':
                    if (controls.isLocked && canDash) performDash();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = false; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = false; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = false; break;
                case 'ArrowRight': case 'KeyD': moveState.right = false; break;
            }
        }

        function performDash() {
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; forward.normalize();
            right.crossVectors(forward, camera.up).normalize();

            const dashDir = new THREE.Vector3();
            if (moveState.forward) dashDir.add(forward);
            if (moveState.backward) dashDir.sub(forward);
            if (moveState.right) dashDir.add(right);
            if (moveState.left) dashDir.sub(right);
            if (dashDir.lengthSq() === 0) dashDir.copy(forward);
            dashDir.normalize();

            velocity.x = dashDir.x * CONFIG.dashSpeed;
            velocity.z = dashDir.z * CONFIG.dashSpeed;
            velocity.y = 5;

            camera.fov = 100;
            camera.updateProjectionMatrix();
            setTimeout(() => { camera.fov = 85; camera.updateProjectionMatrix(); }, 200);

            canDash = false;
            dashTimer = CONFIG.dashCooldown;
            document.getElementById('dash-fill').style.width = '0%';
        }
        
        // --- Debug & World Generation Boilerplate ---
        
        function initDebug() {
            document.getElementById('inp-p-maxhp').value = CONFIG.playerMaxHealth;
            document.getElementById('inp-p-speed').value = CONFIG.moveSpeed;
            document.getElementById('inp-p-dash').value = CONFIG.dashSpeed;
            
            document.getElementById('inp-w-dmg').value = CONFIG.shotgunDamage;
            document.getElementById('inp-w-pellets').value = CONFIG.shotgunPellets;
            document.getElementById('inp-w-spread').value = CONFIG.shotgunSpread;
            
            document.getElementById('inp-e-imphp').value = CONFIG.impHp;
            document.getElementById('inp-e-soldierhp').value = CONFIG.soldierHp;
            document.getElementById('inp-e-aggro').value = CONFIG.aggroRange;

            document.getElementById('debug-btn').addEventListener('click', () => {
                const el = document.getElementById('debug-panel');
                el.style.display = el.style.display === 'block' ? 'none' : 'block';
            });
        }
        
        window.updateConfig = () => {
            CONFIG.playerMaxHealth = Number(document.getElementById('inp-p-maxhp').value);
            CONFIG.moveSpeed = Number(document.getElementById('inp-p-speed').value);
            CONFIG.dashSpeed = Number(document.getElementById('inp-p-dash').value);
            
            CONFIG.shotgunDamage = Number(document.getElementById('inp-w-dmg').value);
            CONFIG.shotgunPellets = Number(document.getElementById('inp-w-pellets').value);
            CONFIG.shotgunSpread = Number(document.getElementById('inp-w-spread').value);
            
            CONFIG.impHp = Number(document.getElementById('inp-e-imphp').value);
            CONFIG.soldierHp = Number(document.getElementById('inp-e-soldierhp').value);
            CONFIG.aggroRange = Number(document.getElementById('inp-e-aggro').value);
        };

        // Reuse City Gen Logic
        function createLava() {
            const geometry = new THREE.PlaneGeometry(1000, 1000, 20, 20);
            const material = new THREE.MeshBasicMaterial({ color: 0xff3300 });
            lavaMesh = new THREE.Mesh(geometry, material);
            lavaMesh.rotation.x = -Math.PI / 2;
            lavaMesh.position.y = CONFIG.lavaHeight;
            scene.add(lavaMesh);
        }

        function generateCity() {
            console.log("Generating Default City...");
            const buildingGeometry = new THREE.BoxGeometry(1, 1, 1);
            const gridSize = 30;
            const buildingBaseSize = 10;
            const blockSize = 3;
            const streetWidth = 15;
            const gap = 2;
            const blockWidth = (buildingBaseSize + gap) * blockSize;
            const totalWidth = (blockWidth + streetWidth) * (gridSize / blockSize);
            const offset = totalWidth / 2;

            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    const blockX = Math.floor(x / blockSize);
                    const blockZ = Math.floor(z / blockSize);
                    const xInBlock = x % blockSize;
                    const zInBlock = z % blockSize;
                    const posX = (blockX * (blockWidth + streetWidth)) + (xInBlock * (buildingBaseSize + gap)) - offset;
                    const posZ = (blockZ * (blockWidth + streetWidth)) + (zInBlock * (buildingBaseSize + gap)) - offset;
                    
                    let isRuined = Math.random() > 0.92;
                    let isToppled = isRuined && Math.random() > 0.5;
                    let width = buildingBaseSize;
                    let depth = buildingBaseSize;
                    let height = Math.random() * 40 + 15;
                    if (isRuined && !isToppled) height = Math.random() * 10 + 2;
                    if (isToppled) {
                        const temp = height; height = width; width = temp;
                        if(Math.random()>0.5) { width = buildingBaseSize; depth = temp; }
                    }

                    const mat = !isToppled ? new THREE.MeshPhongMaterial({ map: windowTexture }) : plainTexture;
                    const mesh = new THREE.Mesh(buildingGeometry, mat);
                    let posY = height / 2;
                    if (isToppled) posY = (Math.random() * 5) + 2;
                    mesh.position.set(posX, posY, posZ);
                    mesh.scale.set(width, height, depth);
                    
                    if (!isToppled) {
                        const h = height/4; const w = width/4;
                        mat.map = windowTexture.clone();
                        mat.map.repeat.set(w, h);
                        mat.map.needsUpdate = true;
                    }

                    scene.add(mesh);
                    buildingMeshes.push(mesh);

                    const box = new THREE.Box3();
                    box.setFromCenterAndSize(new THREE.Vector3(posX, posY, posZ), new THREE.Vector3(width, height, depth));
                    buildings.push(box);
                }
            }
        }

        function updatePlayerCollider() {
            const pos = controls.getObject().position;
            playerCollider.min.set(pos.x - 1, pos.y - 2.5, pos.z - 1);
            playerCollider.max.set(pos.x + 1, pos.y, pos.z + 1);
        }

        function checkCollisions() {
            for (let i = 0; i < buildings.length; i++) {
                if (playerCollider.intersectsBox(buildings[i])) return true;
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>