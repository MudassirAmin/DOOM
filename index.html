<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doom Eternal Movement Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: transparent;
            border: 2px solid #0f0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: #0f0;
            transform: translate(-50%, -50%);
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            pointer-events: none;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 2px solid #0f0;
            cursor: pointer;
        }
        .hud-bar {
            width: 200px;
            height: 10px;
            background: #333;
            margin-top: 5px;
            border: 1px solid #fff;
        }
        #dash-fill {
            width: 100%;
            height: 100%;
            background: #00ffff;
            transition: width 0.1s;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="ui">
        <h2>DOOM MOVEMENT PROTOTYPE</h2>
        <div>WASD to Move</div>
        <div>SPACE to Jump / Double Jump</div>
        <div>SHIFT to Dash (Directional)</div>
        <br>
        <div>DASH COOLDOWN:</div>
        <div class="hud-bar"><div id="dash-fill"></div></div>
    </div>

    <div id="instructions">
        <h1>CLICK TO START</h1>
        <p>Traverse the Cityscape.</p>
        <p>Don't fall into the void.</p>
    </div>

    <!-- Import Three.js as a module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const CONFIG = {
            moveSpeed: 25,
            jumpForce: 25,
            gravity: 60,
            friction: 6, // Air resistance/ground friction
            dashSpeed: 80,
            dashCooldown: 1.5, // Seconds
            playerHeight: 2.5,
            playerRadius: 1.0,
            fovBase: 75,
            fovDash: 100
        };

        // --- Globals ---
        let camera, scene, renderer, controls;
        let raycaster;
        
        // Physics State
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const playerCollider = new THREE.Box3();
        let isGrounded = false;
        let jumpCount = 0;
        let lastTime = performance.now();
        
        // Dash State
        let canDash = true;
        let dashTimer = 0;

        // Input State
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Environment
        const buildings = []; // Array of Box3 for collision
        const worldObjects = []; // Array of Meshes for rendering

        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark stylized sky
            scene.fog = new THREE.FogExp2(0x050510, 0.008);

            // 2. Setup Camera
            camera = new THREE.PerspectiveCamera(CONFIG.fovBase, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 20; // Start in air

            // 3. Setup Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(100, 100, 50);
            scene.add(dirLight);

            // 4. Level Generation (Cityscape)
            generateCity();

            // 5. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 6. Controls
            controls = new PointerLockControls(camera, document.body);

            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => {
                controls.lock();
            });

            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                instructions.style.display = 'block';
            });

            // 7. Input Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
        }

        function generateCity() {
            // Materials
            const wallMat = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 30 });
            const roofMat = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 10 });
            const edgeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true }); // Neon edges

            const buildingGeometry = new THREE.BoxGeometry(1, 1, 1);
            
            // Grid settings
            const gridSize = 20;
            const buildingSize = 15;
            const gap = 2; // Small gap to make jumping necessary but possible
            const offset = (gridSize * (buildingSize + gap)) / 2;

            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    // Randomize height
                    const height = Math.random() * 30 + 10; // 10 to 40 height
                    
                    const mesh = new THREE.Mesh(buildingGeometry, wallMat);
                    
                    // Position
                    const posX = (x * (buildingSize + gap)) - offset;
                    const posZ = (z * (buildingSize + gap)) - offset;
                    const posY = height / 2;

                    mesh.position.set(posX, posY, posZ);
                    mesh.scale.set(buildingSize, height, buildingSize);
                    
                    // Add neon edges for visual clarity
                    const edges = new THREE.LineSegments(
                        new THREE.EdgesGeometry(mesh.geometry),
                        new THREE.LineBasicMaterial({ color: Math.random() > 0.8 ? 0xff00ff : 0x00ffff })
                    );
                    mesh.add(edges);

                    // Add a "roof" pad specifically
                    const roof = new THREE.Mesh(new THREE.PlaneGeometry(1,1), roofMat);
                    roof.rotation.x = -Math.PI/2;
                    roof.position.y = 0.501; // Slightly above
                    mesh.add(roof);

                    scene.add(mesh);
                    worldObjects.push(mesh);

                    // Create Physics collider for this building
                    const box = new THREE.Box3();
                    box.setFromCenterAndSize(
                        new THREE.Vector3(posX, posY, posZ),
                        new THREE.Vector3(buildingSize, height, buildingSize)
                    );
                    buildings.push(box);

                    // Set player spawn on the center building
                    if (x === Math.floor(gridSize/2) && z === Math.floor(gridSize/2)) {
                        camera.position.set(posX, height + 5, posZ);
                    }
                }
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveState.forward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveState.left = true; break;
                case 'ArrowDown':
                case 'KeyS': moveState.backward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveState.right = true; break;
                case 'Space':
                    if (controls.isLocked) {
                        if (isGrounded) {
                            velocity.y = CONFIG.jumpForce;
                            isGrounded = false;
                            jumpCount = 1;
                        } else if (jumpCount < 2) {
                            // Double Jump
                            velocity.y = CONFIG.jumpForce;
                            jumpCount++;
                        }
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    if (controls.isLocked && canDash) performDash();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveState.forward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveState.left = false; break;
                case 'ArrowDown':
                case 'KeyS': moveState.backward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveState.right = false; break;
            }
        }

        function performDash() {
            // Get camera direction
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            right.crossVectors(forward, camera.up).normalize();

            // Determine dash direction based on input, default to forward if no input
            const dashDir = new THREE.Vector3();
            
            if (moveState.forward) dashDir.add(forward);
            if (moveState.backward) dashDir.sub(forward);
            if (moveState.right) dashDir.add(right);
            if (moveState.left) dashDir.sub(right);

            if (dashDir.lengthSq() === 0) dashDir.copy(forward); // Default forward
            
            dashDir.normalize();

            // Apply Dash Force
            velocity.x = dashDir.x * CONFIG.dashSpeed;
            velocity.z = dashDir.z * CONFIG.dashSpeed;
            velocity.y = 5; // Slight hop

            // Visual Effect (FOV Warp)
            camera.fov = CONFIG.fovDash;
            camera.updateProjectionMatrix();
            setTimeout(() => {
                camera.fov = CONFIG.fovBase;
                camera.updateProjectionMatrix();
            }, 200);

            // Cooldown Logic
            canDash = false;
            dashTimer = CONFIG.dashCooldown;
            document.getElementById('dash-fill').style.width = '0%';
        }

        function updatePhysics(delta) {
            if (!controls.isLocked) return;

            // 1. Apply Friction (Damping)
            velocity.x -= velocity.x * CONFIG.friction * delta;
            velocity.z -= velocity.z * CONFIG.friction * delta;

            // 2. Apply Gravity
            velocity.y -= CONFIG.gravity * delta;

            // 3. Get Input Direction
            direction.z = Number(moveState.forward) - Number(moveState.backward);
            direction.x = Number(moveState.right) - Number(moveState.left);
            direction.normalize(); // Ensure consistent speed in all directions

            // 4. Apply Movement Force (Relative to Camera look)
            if (moveState.forward || moveState.backward || moveState.left || moveState.right) {
                const camForward = new THREE.Vector3();
                const camRight = new THREE.Vector3();

                camera.getWorldDirection(camForward);
                camForward.y = 0;
                camForward.normalize();
                
                camRight.crossVectors(camForward, camera.up).normalize();

                const moveVector = new THREE.Vector3();
                moveVector.addScaledVector(camForward, direction.z);
                moveVector.addScaledVector(camRight, direction.x);
                
                // Add acceleration
                velocity.x += moveVector.x * CONFIG.moveSpeed * delta * 5; 
                velocity.z += moveVector.z * CONFIG.moveSpeed * delta * 5;
            }

            // 5. Collision Detection & Position Update
            // We split movement into X, Y, Z steps to handle sliding against walls

            // --- X Axis ---
            controls.getObject().position.x += velocity.x * delta;
            updatePlayerCollider();
            if (checkCollisions()) {
                // Undo Move
                controls.getObject().position.x -= velocity.x * delta;
                velocity.x = 0;
            }

            // --- Z Axis ---
            controls.getObject().position.z += velocity.z * delta;
            updatePlayerCollider();
            if (checkCollisions()) {
                // Undo Move
                controls.getObject().position.z -= velocity.z * delta;
                velocity.z = 0;
            }

            // --- Y Axis (Gravity/Jumping) ---
            controls.getObject().position.y += velocity.y * delta;
            updatePlayerCollider();
            
            isGrounded = false; // Assume falling until collision proves otherwise

            if (checkCollisions()) {
                // Hit something vertical
                const movingUp = velocity.y > 0;
                
                // Undo Move
                controls.getObject().position.y -= velocity.y * delta;
                velocity.y = 0;

                if (!movingUp) {
                    isGrounded = true;
                    jumpCount = 0; // Reset double jump
                }
            }

            // Kill floor (Void)
            if (controls.getObject().position.y < -50) {
                // Respawn high up
                controls.getObject().position.y = 100;
                controls.getObject().position.x = 0;
                controls.getObject().position.z = 0;
                velocity.set(0,0,0);
            }
        }

        function updatePlayerCollider() {
            const pos = controls.getObject().position;
            // Define player box relative to camera position
            // Camera is at the top of the "player", so box extends down
            playerCollider.min.set(pos.x - CONFIG.playerRadius, pos.y - CONFIG.playerHeight, pos.z - CONFIG.playerRadius);
            playerCollider.max.set(pos.x + CONFIG.playerRadius, pos.y, pos.z + CONFIG.playerRadius);
        }

        function checkCollisions() {
            for (let i = 0; i < buildings.length; i++) {
                if (playerCollider.intersectsBox(buildings[i])) {
                    return true;
                }
            }
            return false;
        }

        function updateDashCooldown(delta) {
            if (!canDash) {
                dashTimer -= delta;
                const pct = 100 - (dashTimer / CONFIG.dashCooldown * 100);
                document.getElementById('dash-fill').style.width = `${Math.min(pct, 100)}%`;

                if (dashTimer <= 0) {
                    canDash = true;
                    document.getElementById('dash-fill').style.width = '100%';
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            // Cap delta to prevent physics explosion on lag spikes
            const safeDelta = Math.min(delta, 0.1);

            updatePhysics(safeDelta);
            updateDashCooldown(safeDelta);

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>