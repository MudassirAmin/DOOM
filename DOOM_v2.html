<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doom Eternal Movement Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: transparent;
            border: 2px solid #0f0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: #0f0;
            transform: translate(-50%, -50%);
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            pointer-events: none;
            z-index: 5;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border: 2px solid #0f0;
            cursor: pointer;
            z-index: 20;
            min-width: 300px;
        }
        .hud-bar {
            width: 200px;
            height: 10px;
            background: #333;
            margin-top: 5px;
            border: 1px solid #fff;
        }
        #dash-fill {
            width: 100%;
            height: 100%;
            background: #00ffff;
            transition: width 0.1s;
        }
        
        /* Settings Menu */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 30;
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            cursor: pointer;
            font-family: inherit;
        }
        #settings-panel {
            display: none;
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0f0;
            padding: 20px;
            z-index: 30;
            color: white;
            width: 200px;
        }
        .setting-row {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        button.toggle {
            background: #333;
            color: white;
            border: 1px solid #666;
            cursor: pointer;
            padding: 5px 10px;
        }
        button.toggle:hover { background: #555; }
        button.toggle.active { background: #0f0; color: black; }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    
    <div id="ui">
        <h2>DOOM MOVEMENT v2</h2>
        <div>WASD to Move</div>
        <div>SPACE to Jump / Double Jump</div>
        <div>SHIFT to Dash</div>
        <br>
        <div>DASH COOLDOWN:</div>
        <div class="hud-bar"><div id="dash-fill"></div></div>
    </div>

    <button id="settings-btn">SETTINGS</button>
    <div id="settings-panel">
        <h3>GRAPHICS</h3>
        <div class="setting-row">
            <span>Textures</span>
            <button id="btn-tex" class="toggle active" onclick="toggleTextures()">ON</button>
        </div>
        <div class="setting-row">
            <span>Neon Edges</span>
            <button id="btn-neon" class="toggle active" onclick="toggleNeon()">ON</button>
        </div>
        <div class="setting-row">
            <small style="color:#aaa">Press ESC to use mouse</small>
        </div>
    </div>

    <div id="instructions">
        <h1 style="margin-top:0">PAUSED</h1>
        <p>Traverse the Cityscape.</p>
        <p>Avoid the LAVA below.</p>
        <br>
        <div style="font-size: 1.5em; border: 1px solid #fff; padding: 10px; display:inline-block;">CLICK TO PLAY</div>
    </div>

    <!-- Import Three.js as a module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const CONFIG = {
            moveSpeed: 25,
            jumpForce: 25,
            gravity: 60,
            friction: 6, 
            dashSpeed: 80,
            dashCooldown: 1.5,
            playerHeight: 2.5,
            playerRadius: 1.0,
            fovBase: 75,
            fovDash: 100,
            lavaHeight: 2
        };

        // --- Globals ---
        let camera, scene, renderer, controls;
        
        // Physics
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const playerCollider = new THREE.Box3();
        let isGrounded = false;
        let jumpCount = 0;
        let lastTime = performance.now();
        
        // Game State
        let canDash = true;
        let dashTimer = 0;
        let lavaMesh;
        
        // Settings State
        window.gameSettings = {
            textures: true,
            neon: true
        };

        const moveState = { forward: false, backward: false, left: false, right: false };
        const buildings = []; // Physics boxes
        const worldObjects = []; // Added missing declaration
        const buildingMeshes = []; // Visual meshes
        const edgeMeshes = []; // Visual edges

        // Texture Assets
        let windowTexture, plainTexture;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0505); // Reddish dark sky
            scene.fog = new THREE.FogExp2(0x1a0505, 0.006);

            camera = new THREE.PerspectiveCamera(CONFIG.fovBase, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 50; 

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffaaaa, 0.5); 
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 100, 50);
            scene.add(dirLight);

            // Generate Assets
            windowTexture = createBuildingTexture();
            plainTexture = new THREE.MeshPhongMaterial({ color: 0x333333 });

            // World Generation
            generateCity();
            createLava();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            
            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => {
                if(!controls.isLocked) controls.lock();
            });

            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                document.getElementById('settings-panel').style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                instructions.style.display = 'block';
            });

            // Input
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            // Settings UI Logic
            document.getElementById('settings-btn').addEventListener('click', () => {
                const panel = document.getElementById('settings-panel');
                panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            });

            // Expose toggle functions to global scope for HTML onclick
            window.toggleTextures = () => {
                window.gameSettings.textures = !window.gameSettings.textures;
                document.getElementById('btn-tex').classList.toggle('active');
                updateBuildingVisuals();
            };
            window.toggleNeon = () => {
                window.gameSettings.neon = !window.gameSettings.neon;
                document.getElementById('btn-neon').classList.toggle('active');
                edgeMeshes.forEach(e => e.visible = window.gameSettings.neon);
            };
        }

        // --- Procedural Generation ---

        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Base wall
            ctx.fillStyle = '#222';
            ctx.fillRect(0,0,64,64);
            
            // Windows
            ctx.fillStyle = '#445'; // Dark blue-ish windows
            // Random lights
            
            for(let y=4; y<64; y+=12) {
                for(let x=4; x<64; x+=12) {
                    if (Math.random() > 0.3) {
                        ctx.fillStyle = Math.random() > 0.9 ? '#ffaa00' : '#88ccff'; // Some lights on
                    } else {
                        ctx.fillStyle = '#111'; // Lights off
                    }
                    ctx.fillRect(x, y, 6, 8);
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        function createLava() {
            const geometry = new THREE.PlaneGeometry(1000, 1000, 20, 20);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff3300, 
                wireframe: false 
            });
            lavaMesh = new THREE.Mesh(geometry, material);
            lavaMesh.rotation.x = -Math.PI / 2;
            lavaMesh.position.y = CONFIG.lavaHeight;
            scene.add(lavaMesh);
        }

        function generateCity() {
            const buildingGeometry = new THREE.BoxGeometry(1, 1, 1);
            const roofMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

            const gridSize = 30;
            const buildingBaseSize = 10;
            const blockSize = 3; // Buildings per block side
            const streetWidth = 15;
            const gap = 2;
            
            // Calculate total map size to center it
            const blockWidth = (buildingBaseSize + gap) * blockSize;
            const totalWidth = (blockWidth + streetWidth) * (gridSize / blockSize);
            const offset = totalWidth / 2;

            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    
                    // Determine position
                    const blockX = Math.floor(x / blockSize);
                    const blockZ = Math.floor(z / blockSize);
                    
                    const xInBlock = x % blockSize;
                    const zInBlock = z % blockSize;

                    // Calculate world pos including streets
                    const posX = (blockX * (blockWidth + streetWidth)) + (xInBlock * (buildingBaseSize + gap)) - offset;
                    const posZ = (blockZ * (blockWidth + streetWidth)) + (zInBlock * (buildingBaseSize + gap)) - offset;

                    // Building Logic
                    let isRuined = Math.random() > 0.92;
                    let isToppled = isRuined && Math.random() > 0.5;
                    
                    let width = buildingBaseSize;
                    let depth = buildingBaseSize;
                    let height = Math.random() * 40 + 15;

                    if (isRuined && !isToppled) {
                        height = Math.random() * 10 + 2; // Short stump
                    }

                    // Toppled Logic (Swap dimensions essentially)
                    if (isToppled) {
                        const temp = height;
                        height = width; // Flattened
                        width = temp;   // Stretched along X axis (fallen over)
                        // Or random axis
                        if(Math.random() > 0.5) {
                            width = buildingBaseSize;
                            depth = temp;
                        }
                    }

                    const mesh = new THREE.Mesh(buildingGeometry, plainTexture.clone()); // Placeholder mat
                    
                    // Position
                    let posY = height / 2;
                    if (isToppled) posY = (Math.random() * 5) + 2; // Sinking slightly

                    mesh.position.set(posX, posY, posZ);
                    mesh.scale.set(width, height, depth);

                    // UV Mapping scaling for textures
                    mesh.userData = { 
                        isToppled: isToppled, 
                        originalHeight: height,
                        width: width,
                        depth: depth
                    };

                    // Edges
                    const edges = new THREE.LineSegments(
                        new THREE.EdgesGeometry(mesh.geometry),
                        new THREE.LineBasicMaterial({ color: isRuined ? 0xff3300 : (Math.random() > 0.8 ? 0xff00ff : 0x00ffff) })
                    );
                    mesh.add(edges);
                    edgeMeshes.push(edges);

                    // Roof (Only for non-toppled, tall buildings)
                    if (!isToppled && height > 10) {
                        const roof = new THREE.Mesh(new THREE.PlaneGeometry(1,1), roofMat);
                        roof.rotation.x = -Math.PI/2;
                        roof.position.y = 0.501;
                        mesh.add(roof);
                    }

                    scene.add(mesh);
                    buildingMeshes.push(mesh);
                    worldObjects.push(mesh);

                    // Collision Box
                    const box = new THREE.Box3();
                    box.setFromCenterAndSize(
                        new THREE.Vector3(posX, posY, posZ),
                        new THREE.Vector3(width, height, depth)
                    );
                    buildings.push(box);

                    // Spawn Point (Find a safe central block)
                    if (blockX === 3 && blockZ === 3 && xInBlock === 1 && zInBlock === 1) {
                        camera.position.set(posX, height + 5, posZ);
                    }
                }
            }
            updateBuildingVisuals();
        }

        function updateBuildingVisuals() {
            const useTexture = window.gameSettings.textures;
            
            buildingMeshes.forEach(mesh => {
                if (useTexture && !mesh.userData.isToppled) {
                    const mat = new THREE.MeshPhongMaterial({ map: windowTexture });
                    // Adjust texture repeat
                    const h = mesh.userData.originalHeight / 4;
                    const w = mesh.userData.width / 4;
                    mat.map.repeat.set(w, h);
                    mesh.material = mat;
                } else {
                    mesh.material = new THREE.MeshPhongMaterial({ 
                        color: mesh.userData.isToppled ? 0x221111 : 0x333333,
                        shininess: 30 
                    });
                }
            });
        }

        // --- Game Logic ---

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = true; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = true; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = true; break;
                case 'ArrowRight': case 'KeyD': moveState.right = true; break;
                case 'Space':
                    if (controls.isLocked) {
                        if (isGrounded) {
                            velocity.y = CONFIG.jumpForce;
                            isGrounded = false;
                            jumpCount = 1;
                        } else if (jumpCount < 2) {
                            velocity.y = CONFIG.jumpForce;
                            jumpCount++;
                        }
                    }
                    break;
                case 'ShiftLeft': case 'ShiftRight':
                    if (controls.isLocked && canDash) performDash();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = false; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = false; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = false; break;
                case 'ArrowRight': case 'KeyD': moveState.right = false; break;
            }
        }

        function performDash() {
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; forward.normalize();
            right.crossVectors(forward, camera.up).normalize();

            const dashDir = new THREE.Vector3();
            if (moveState.forward) dashDir.add(forward);
            if (moveState.backward) dashDir.sub(forward);
            if (moveState.right) dashDir.add(right);
            if (moveState.left) dashDir.sub(right);
            if (dashDir.lengthSq() === 0) dashDir.copy(forward);
            dashDir.normalize();

            velocity.x = dashDir.x * CONFIG.dashSpeed;
            velocity.z = dashDir.z * CONFIG.dashSpeed;
            velocity.y = 5;

            camera.fov = CONFIG.fovDash;
            camera.updateProjectionMatrix();
            setTimeout(() => { camera.fov = CONFIG.fovBase; camera.updateProjectionMatrix(); }, 200);

            canDash = false;
            dashTimer = CONFIG.dashCooldown;
            document.getElementById('dash-fill').style.width = '0%';
        }

        function updatePhysics(delta) {
            if (!controls.isLocked) return;

            velocity.x -= velocity.x * CONFIG.friction * delta;
            velocity.z -= velocity.z * CONFIG.friction * delta;
            velocity.y -= CONFIG.gravity * delta;

            direction.z = Number(moveState.forward) - Number(moveState.backward);
            direction.x = Number(moveState.right) - Number(moveState.left);
            direction.normalize();

            if (moveState.forward || moveState.backward || moveState.left || moveState.right) {
                const camForward = new THREE.Vector3();
                const camRight = new THREE.Vector3();
                camera.getWorldDirection(camForward);
                camForward.y = 0; camForward.normalize();
                camRight.crossVectors(camForward, camera.up).normalize();

                const moveVector = new THREE.Vector3();
                moveVector.addScaledVector(camForward, direction.z);
                moveVector.addScaledVector(camRight, direction.x);
                
                velocity.x += moveVector.x * CONFIG.moveSpeed * delta * 5; 
                velocity.z += moveVector.z * CONFIG.moveSpeed * delta * 5;
            }

            // X Movement
            controls.getObject().position.x += velocity.x * delta;
            updatePlayerCollider();
            if (checkCollisions()) {
                controls.getObject().position.x -= velocity.x * delta;
                velocity.x = 0;
            }

            // Z Movement
            controls.getObject().position.z += velocity.z * delta;
            updatePlayerCollider();
            if (checkCollisions()) {
                controls.getObject().position.z -= velocity.z * delta;
                velocity.z = 0;
            }

            // Y Movement
            controls.getObject().position.y += velocity.y * delta;
            updatePlayerCollider();
            isGrounded = false;
            if (checkCollisions()) {
                const movingUp = velocity.y > 0;
                controls.getObject().position.y -= velocity.y * delta;
                velocity.y = 0;
                if (!movingUp) {
                    isGrounded = true;
                    jumpCount = 0;
                }
            }

            // Lava Death
            if (controls.getObject().position.y < CONFIG.lavaHeight + 1) {
                // Respawn Logic
                respawn();
            }
        }

        function respawn() {
            // Find nearest safe building top
            const playerPos = controls.getObject().position;
            let bestY = 100;
            let bestX = 0;
            let bestZ = 0;
            
            // Just reset to high up in current XZ for now, or back to start
            controls.getObject().position.y = 50;
            velocity.set(0,0,0);
        }

        function updatePlayerCollider() {
            const pos = controls.getObject().position;
            playerCollider.min.set(pos.x - CONFIG.playerRadius, pos.y - CONFIG.playerHeight, pos.z - CONFIG.playerRadius);
            playerCollider.max.set(pos.x + CONFIG.playerRadius, pos.y, pos.z + CONFIG.playerRadius);
        }

        function checkCollisions() {
            for (let i = 0; i < buildings.length; i++) {
                if (playerCollider.intersectsBox(buildings[i])) return true;
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            updatePhysics(delta);

            if (!canDash) {
                dashTimer -= delta;
                const pct = 100 - (dashTimer / CONFIG.dashCooldown * 100);
                document.getElementById('dash-fill').style.width = `${Math.min(pct, 100)}%`;
                if (dashTimer <= 0) {
                    canDash = true;
                    document.getElementById('dash-fill').style.width = '100%';
                }
            }

            // Animate Lava
            if (lavaMesh) {
                // Simple color pulsing
                const pulse = (Math.sin(time * 0.002) + 1) * 0.2 + 0.5;
                lavaMesh.material.color.setHSL(0.05, 1, 0.5 * pulse);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>